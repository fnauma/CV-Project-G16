<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Reconstruction Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000000;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 6px;
            user-select: none;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 6px;
            user-select: none;
            line-height: 1.6;
        }
        
        #view-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
        }
        
        .view-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            user-select: none;
        }
        
        .view-btn:hover {
            background: rgba(0, 0, 0, 0.7);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 16px;
            text-align: center;
        }
        
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <div><strong>Navigation</strong></div>
        <div>Left drag: Rotate</div>
        <div>Right drag: Pan</div>
        <div>Scroll: Zoom</div>
        <div>Space: Next view</div>
    </div>
    
    <div id="info">
        <div>Points: <span id="point-count">0</span></div>
        <div>View: <span id="current-view">1</span> / <span id="total-views">0</span></div>
    </div>
    
    <div id="view-buttons">
        <button class="view-btn" onclick="previousView()">← Prev</button>
        <button class="view-btn" onclick="nextView()">Next →</button>
        <button class="view-btn" onclick="resetCamera()">Reset</button>
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading reconstruction...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // OrbitControls implementation
        (function() {
            THREE.OrbitControls = function(object, domElement) {
                this.object = object;
                this.domElement = domElement || document;
                
                this.enabled = true;
                this.target = new THREE.Vector3();
                
                this.minDistance = 0;
                this.maxDistance = Infinity;
                
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI;
                
                this.enableDamping = true;
                this.dampingFactor = 0.05;
                
                this.enablePan = true;
                this.panSpeed = 1.0;
                
                this.enableZoom = true;
                this.zoomSpeed = 1.0;
                
                this.enableRotate = true;
                this.rotateSpeed = 1.0;
                
                const scope = this;
                const STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2 };
                let state = STATE.NONE;
                
                const spherical = new THREE.Spherical();
                const sphericalDelta = new THREE.Spherical();
                let scale = 1;
                const panOffset = new THREE.Vector3();
                
                const rotateStart = new THREE.Vector2();
                const rotateEnd = new THREE.Vector2();
                const rotateDelta = new THREE.Vector2();
                
                const panStart = new THREE.Vector2();
                const panEnd = new THREE.Vector2();
                const panDelta = new THREE.Vector2();
                
                const offset = new THREE.Vector3();
                const quat = new THREE.Quaternion().setFromUnitVectors(
                    object.up, new THREE.Vector3(0, 1, 0)
                );
                const quatInverse = quat.clone().invert();
                
                function rotateLeft(angle) {
                    sphericalDelta.theta -= angle;
                }
                
                function rotateUp(angle) {
                    sphericalDelta.phi -= angle;
                }
                
                function panLeft(distance, objectMatrix) {
                    const v = new THREE.Vector3();
                    v.setFromMatrixColumn(objectMatrix, 0);
                    v.multiplyScalar(-distance);
                    panOffset.add(v);
                }
                
                function panUp(distance, objectMatrix) {
                    const v = new THREE.Vector3();
                    v.setFromMatrixColumn(objectMatrix, 1);
                    v.multiplyScalar(distance);
                    panOffset.add(v);
                }
                
                function pan(deltaX, deltaY) {
                    const element = scope.domElement;
                    const offset = new THREE.Vector3();
                    const position = scope.object.position;
                    offset.copy(position).sub(scope.target);
                    let targetDistance = offset.length();
                    targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);
                    panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
                    panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
                }
                
                function dollyIn(dollyScale) {
                    scale /= dollyScale;
                }
                
                function dollyOut(dollyScale) {
                    scale *= dollyScale;
                }
                
                this.update = function() {
                    const position = scope.object.position;
                    offset.copy(position).sub(scope.target);
                    offset.applyQuaternion(quat);
                    spherical.setFromVector3(offset);
                    
                    spherical.theta += sphericalDelta.theta;
                    spherical.phi += sphericalDelta.phi;
                    
                    spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
                    spherical.makeSafe();
                    spherical.radius *= scale;
                    spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
                    
                    scope.target.add(panOffset);
                    offset.setFromSpherical(spherical);
                    offset.applyQuaternion(quatInverse);
                    position.copy(scope.target).add(offset);
                    scope.object.lookAt(scope.target);
                    
                    if (scope.enableDamping) {
                        sphericalDelta.theta *= (1 - scope.dampingFactor);
                        sphericalDelta.phi *= (1 - scope.dampingFactor);
                        panOffset.multiplyScalar(1 - scope.dampingFactor);
                    } else {
                        sphericalDelta.set(0, 0, 0);
                        panOffset.set(0, 0, 0);
                    }
                    
                    scale = 1;
                    return false;
                };
                
                function onMouseDown(event) {
                    if (!scope.enabled) return;
                    event.preventDefault();
                    
                    if (event.button === 0) {
                        if (!scope.enableRotate) return;
                        rotateStart.set(event.clientX, event.clientY);
                        state = STATE.ROTATE;
                    } else if (event.button === 2) {
                        if (!scope.enablePan) return;
                        panStart.set(event.clientX, event.clientY);
                        state = STATE.PAN;
                    }
                    
                    if (state !== STATE.NONE) {
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    }
                }
                
                function onMouseMove(event) {
                    if (!scope.enabled) return;
                    event.preventDefault();
                    
                    if (state === STATE.ROTATE) {
                        rotateEnd.set(event.clientX, event.clientY);
                        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
                        const element = scope.domElement;
                        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
                        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
                        rotateStart.copy(rotateEnd);
                    } else if (state === STATE.PAN) {
                        panEnd.set(event.clientX, event.clientY);
                        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
                        pan(panDelta.x, panDelta.y);
                        panStart.copy(panEnd);
                    }
                    
                    scope.update();
                }
                
                function onMouseUp() {
                    if (!scope.enabled) return;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    state = STATE.NONE;
                }
                
                function onMouseWheel(event) {
                    if (!scope.enabled || !scope.enableZoom || state !== STATE.NONE) return;
                    event.preventDefault();
                    event.stopPropagation();
                    
                    if (event.deltaY < 0) {
                        dollyOut(0.95);
                    } else if (event.deltaY > 0) {
                        dollyIn(0.95);
                    }
                    
                    scope.update();
                }
                
                function onContextMenu(event) {
                    if (!scope.enabled) return;
                    event.preventDefault();
                }
                
                this.domElement.addEventListener('contextmenu', onContextMenu);
                this.domElement.addEventListener('mousedown', onMouseDown);
                this.domElement.addEventListener('wheel', onMouseWheel);
            };
        })();

        // Main application
        let scene, camera, renderer, controls;
        let pointCloud;
        let cameras = [];
        let currentCameraIndex = 0;
        let isTransitioning = false;
        let sceneCenter, sceneSize;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        function onClickCameraMarker(event) 
        {
            const rect = renderer.domElement.getBoundingClientRect();

            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(scene.children);
            const hit = intersects.find(obj => obj.object.userData.cameraIndex !== undefined);

            if (hit) {
                const index = hit.object.userData.cameraIndex;
                setViewFromCamera(index);
            }
        }

        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.01,
                1000
            );
            camera.position.set(2, 2, 5);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.5;
            controls.panSpeed = 0.8;
            controls.zoomSpeed = 1.2;

            renderer.domElement.addEventListener('pointerdown', onClickCameraMarker);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            
            // Load data
            loadReconstruction();
        }

        function addCameraMarkers() {
            const geo = new THREE.SphereGeometry(0.05, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff4444 });

            cameras.forEach((cam, i) => {
                const marker = new THREE.Mesh(geo, mat.clone());
                marker.position.set(cam.center[0], cam.center[1], cam.center[2]);
                marker.userData.cameraIndex = i;
                scene.add(marker);
            });
        }

        
        async function loadReconstruction() {
            try {
                // Load cameras
                const cameraResponse = await fetch('all_cameras.json');
                const cameraData = await cameraResponse.json();
                cameras = cameraData.cameras;
                
                document.getElementById('total-views').textContent = cameras.length;
                
                // Load point cloud
                const plyResponse = await fetch('merged_room.ply');
                if (plyResponse.ok)
                {
                    const plyText = await plyResponse.text();
                    pointCloud = parsePLY(plyText);
                }
                
                scene.add(pointCloud);
                
                document.getElementById('point-count').textContent = 
                    pointCloud.geometry.attributes.position.count.toLocaleString();
                
                // Calculate and store scene bounds
                const box = new THREE.Box3().setFromObject(pointCloud);
                sceneCenter = box.getCenter(new THREE.Vector3());
                sceneSize = box.getSize(new THREE.Vector3());
                
                // Center camera on point cloud
                controls.target.copy(sceneCenter);
                const maxDim = Math.max(sceneSize.x, sceneSize.y, sceneSize.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5;
                
                camera.position.set(sceneCenter.x, sceneCenter.y + maxDim * 0.3, sceneCenter.z + cameraZ);
                camera.lookAt(sceneCenter);
                controls.update();
                
                document.getElementById('loading').classList.add('hidden');
                animate();
                addCameraMarkers();
                
            } catch (error) {
                console.error('Error loading:', error);
                document.getElementById('loading').innerHTML = 
                    '<p style="color: #ff6b6b;">Error loading reconstruction</p>' +
                    '<p style="font-size: 12px; margin-top: 10px;">Check console for details</p>';
            }

        }

        function parsePLY(plyText) {
            const lines = plyText.split('\n');
            let vertexCount = 0;
            const vertices = [];
            const colors = [];
            let hasColor = false;
            let hasNormals = false;
            let propertyCount = 0;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                if (line.startsWith('element vertex')) {
                    vertexCount = parseInt(line.split(' ')[2]);
                }

                if (line.startsWith('property')) {
                    propertyCount++;
                    if (line.includes('red') || line.includes('green') || line.includes('blue')) {
                        hasColor = true;
                    }
                    if (line.includes(' nx') || line.includes(' ny') || line.includes(' nz')) {
                        hasNormals = true;
                    }
                }

                if (line === 'end_header') {
                    const colorOffset = hasNormals ? 6 : 3;
                    for (let j = i + 1; j < i + 1 + vertexCount && j < lines.length; j++) {
                        const parts = lines[j].trim().split(/\s+/);
                        if (parts.length >= 3) {
                            vertices.push(parseFloat(parts[0]), parseFloat(parts[1]), parseFloat(parts[2]));

                            if (hasColor && parts.length >= colorOffset + 3) {
                                colors.push(
                                    parseInt(parts[colorOffset]) / 255,
                                    parseInt(parts[colorOffset + 1]) / 255,
                                    parseInt(parts[colorOffset + 2]) / 255
                                );
                            } else {
                                colors.push(0.6, 0.7, 0.8);
                            }
                        }
                    }
                    break;
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                sizeAttenuation: true
            });

            return new THREE.Points(geometry, material);
        }
        
        function setViewFromCamera(index) {
            if (index < 0 || index >= cameras.length || isTransitioning) return;

            isTransitioning = true;
            const cam = cameras[index];

            const camPos = new THREE.Vector3(
                cam.center[0],
                cam.center[1],
                cam.center[2]
            );

            // forward direction from rotation matrix (world → camera)
            const R = cam.rotation;
            const forward = new THREE.Vector3(
                -R[0][2],
                -R[1][2],
                -R[2][2]
            ).normalize();

            // Look target = forward direction from camera
            const lookTarget = camPos.clone().add(forward.multiplyScalar(0.7));

            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();

            const duration = 900;
            const startTime = performance.now();

            function animateCam() {
                const t = Math.min((performance.now() - startTime) / duration, 1);
                const eased = t * (2 - t);

                camera.position.lerpVectors(startPos, camPos, eased);
                controls.target.lerpVectors(startTarget, lookTarget, eased);

                controls.update();

                if (t < 1) requestAnimationFrame(animateCam);
                else {
                    currentCameraIndex = index;
                    document.getElementById('current-view').textContent = index + 1;
                    isTransitioning = false;
                }
            }

            animateCam();
        }

        
        function nextView() {
            if (cameras.length === 0) return;
            const next = (currentCameraIndex + 1) % cameras.length;
            setViewFromCamera(next);
        }
        
        function previousView() {
            if (cameras.length === 0) return;
            const prev = (currentCameraIndex - 1 + cameras.length) % cameras.length;
            setViewFromCamera(prev);
        }
        
        function resetCamera() {
            if (!pointCloud) return;
            
            const box = new THREE.Box3().setFromObject(pointCloud);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            controls.target.copy(center);
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.5;
            
            camera.position.set(center.x, center.y + maxDim * 0.3, center.z + cameraZ);
            camera.lookAt(center);
            controls.update();
        }
        
        function onKeyDown(event) {
            if (event.code === 'Space') {
                event.preventDefault();
                nextView();
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>
